---
SPDX-License-Identifier: MIT
path: "/tutorials/setup-your-own-scalable-kubernetes-cluster"
slug: "setup-your-own-scalable-kubernetes-cluster"
date: "2024-04-08"
title: "Setup your own scalable kubernetes cluster"
short_description: "Create a scalable kubernetes cluster on Hetzner Cloud using Terraform and k3s"
tags: [ "Ubuntu", "Terraform", "Kubernetes" ]
author: "Alexandru Popescu"
author_link: "https://github.com/Blue25GD"
author_img: "https://avatars.githubusercontent.com/u/113828070?s=400&u=f362ae342f1c16b94cfabf82da61781d09d04923&v=4"
author_description: "Creating awesome web products"
language: "en"
available_languages: [ "en" ]
header_img: ""
cta: "product"
---

## Introduction

We all know how much of a headache installing Kubernetes manually is, especially scaling it as your workload grows. Yet,
in the realm of modern containerized applications, Kubernetes remains the undisputed champion in orchestrating workloads
efficiently. Fortunately, there's a light at the end of the tunnel. In this article, we're diving headfirst into the
process of building your own scalable Kubernetes cluster on Hetzner.

**Prerequisites**

* Hetzner Cloud [API token](https://docs.hetzner.com/cloud/api/getting-started/generating-api-token) in
  the [Cloud Console](https://console.hetzner.cloud/)
* [SSH key](https://community.hetzner.com/tutorials/howto-ssh-key)
* Basic knowledge of [Docker](https://docker.com) and [Kubernetes](https://k8s.io)
* [Terraform](https://developer.hashicorp.com/terraform/install?product_intent=terraform) installed on your local
  machine

**Example terminology**

* Hetzner Cloud: `hcloud`
* Hetzner Cloud API token: `<your_api_token>`
* `node` is a fancy word for a server

## Step 1 - Creation of the project

On your computer, create a new folder, you can name it however you want. Here we'll go with `kubernetes-cluster`.

```shell
mkdir kubernetes-cluster && cd kubernetes-cluser
```

In that folder, create two files named `main.tf` and `.tfvars`.
`main.tf` will be used to declare hcloud terraform ressources, `.tfvars` will be used to configure the hcloud provider
with your API token and hide it at the same time.

```shell
touch main.tf && touch .tfvars
```

### Step 1.1 - Setting up the hcloud provider

After creating the two files, add the following to the `main.tf` file:

```terraform
# Tell Terraform to include the hcloud provider
terraform {
  required_providers {
    hcloud = {
      source  = "hetznercloud/hcloud"
      # Here we use version 1.45.0, this may change in the future
      version = "1.45.0"
    }
  }
}

# Declare the hcloud_token variable from .tfvars
variable "hcloud_token" {
  sensitive = true # Requires terraform >= 0.14
}

# Configure the Hetzner Cloud Provider with your token
provider "hcloud" {
  token = var.hcloud_token
}
```

This will fail to initialize the hcloud provider because the variable `hcloud_token` has not yet been declared
in `.tfvars`. To fix this, add the following to the `.tfvars` file:

```terraform
hcloud_token = "<your_api_token>"
```

Just like a .env file, the `.tfvars` file can be used to initialize secrets and global variables that you don't want in
your code.

### Step 1.2 Initialize the project

Lastly, run the following command to initialize the project and download the `hcloud` provider:

```shell
terraform init
```

## Step 2 - Setup your master node

Now that terraform is ready for hcloud, we need to create the most important part of the cluster, the master node.

The master node controls all of the other worker nodes, it's the brain of the cluster.

![Master node vs worker node](images/diagram-1.png)

### Step 2.1 - Create a private network for the cluster

Later on, you'll want to add more nodes, worker nodes. They need to communicate without being exposed to the public,
they need to be in a private network.

Add the following code to your `main.tf` file:

```terraform
resource "hcloud_network" "private_network" {
  name     = "kubernetes-cluster"
  ip_range = "10.0.0.0/16"
}

resource "hcloud_network_subnet" "private_network_subnet" {
  type         = "cloud"
  network_id   = hcloud_network.private_network.id
  network_zone = "eu-central"
  ip_range     = "10.0.1.0/24"
}

```

This will create a private network named `kubernetes-cluster` that will be used by the nodes to communicate with each
other.

### Step 2.2 Create the node

When creating a node on hcloud, you can add what is called a `cloud-init` script to it. This script will be executed
when the node is created, and it can be used to install software, configure the node, and more. In this case, we'll use
it to install Kubernetes.

```yaml
#cloud-config
packages:
  - curl
users:
  - name: <your_username>
    ssh-authorized-keys:
      - <your-ssh-public-key>
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
runcmd:
  - apt-get update -y
  - curl https://get.k3s.io | INSTALL_K3S_EXEC="--disable traefik" sh -
```

Put the content above in a file named `cloud-init.yaml` and replace `<your_username>` with a username of your choice and
`<your_public_ssh_key>` with your public ssh key.

You might have noticed that instead of installing k8s the traditional way, we're using `k3s`. This is because `k3s` is a
lightweight k8s distribution that makes it way easier to install and manage k8s clusters. This tutorial would be way too
long if we were to install k8s the traditional way.

Also, we're disabling `traefik` because we'll be using `nginx` as an ingress controller for later on.

Before we continue, you must choose a plan for your master node. You can find the available
plans [here](https://www.hetzner.com/cloud#pricing). Because k3s is optimized for arm64, we'll go with the `cax11` plan from hcloud's arm64 instances.

| Plan    | CPU | Memory | Disk |
|---------|-----|--------|------|
| `cax11` | 2   | 4GB    | 40GB |

Add the following code to your `main.tf` file:

```terraform
resource "hcloud_server" "master-node" {
  name        = "master-node"
  image       = "ubuntu-22.04"
  server_type = "cax11"
  location    = "fsn1"
  public_net {
    ipv4_enabled = true
    ipv6_enabled = true
  }
  network {
    network_id = hcloud_network.private_network.id
    # IP Used by the master node, needs to be static
    # Here the worker nodes will use 10.0.1.1 to communicate with the master node
    ip         = "10.0.1.1"
  }
  user_data = file("${path.module}/cloud-init.yaml")

  # If we don't specify this, terraform will create the resources in parallel
  # We want this node to be created after the private network is created
  depends_on = [hcloud_network_subnet.private_network_subnet]
}
```

## Step 3 - Setup your worker nodes

Now that the master node is ready, we need to give it some more juice. While you can scale the master node by giving it more CPU's and memory, eventually you'll hit a limit. This is where worker nodes come in.

![Horizontal vs vertical scaling](images/diagram-2.png)

### Step 3.1 - Create your first worker node

Add the following code to your `main.tf` file:

```terraform
resource "hcloud_server" "worker-node-1" {
  name        = "worker-node-1"
  image       = "ubuntu-22.04"
  server_type = "cax11"
  location    = "fsn1"
  public_net {
    ipv4_enabled = true
    ipv6_enabled = true
  }
  network {
    network_id = hcloud_network.private_network.id
  }
  user_data = file("${path.module}/cloud-init-worker.yaml")

  # add the master node as a dependency
  depends_on = [hcloud_network_subnet.private_network_subnet, hcloud_server.master-node]
}
```

The `cloud-init-worker.yaml` file will be similar to the `cloud-init.yaml` file, but it will not install k3s the same way. Instead, it will join the worker node to the master node with a command similar to this:

```shell
curl -sfL https://get.k3s.io | K3S_URL=https://10.0.1.1:6443 K3S_TOKEN=<will_be_diffferent_every_time> sh -
```

cloud-init-worker.yaml:
```yaml
#cloud-config
packages:
  - curl
users:
  - name: cluster
    ssh-authorized-keys:
      - <your_public_ssh_key>
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash

write_files:
  - path: /root/.ssh/id_rsa
    content: |
      -----BEGIN OPENSSH PRIVATE KEY-----
      <your_private_ssh_key>
      -----END OPENSSH PRIVATE KEY-----
    permissions: "0600"

runcmd:
  - apt-get update -y
  - # wait for the master node to be ready by trying to connect to it
  - until curl -k https://10.0.1.1:6443; do sleep 5; done
  - # copy the token from the master node
  - REMOTE_TOKEN=$(ssh -o StrictHostKeyChecking=accept-new cluster@10.0.1.1 sudo cat /var/lib/rancher/k3s/server/node-token)
  - # Install k3s worker
  - curl -sfL https://get.k3s.io | K3S_URL=https://10.0.1.1:6443 K3S_TOKEN=$REMOTE_TOKEN sh -
```

### Step 3.2 (optional) - Scale your worker nodes

You can put resources in a loop in terraform, so you can create as many worker nodes as you want. Here's an example of how you can create 3 worker nodes:

```terraform
resource "hcloud_server" "worker-nodes" {
  count       = 3
  
  # The name will be worker-node-0, worker-node-1, worker-node-2...
  name        = "worker-node-${count.index}"
  image       = "ubuntu-22.04"
  server_type = "cax11"
  location    = "fsn1"
  public_net {
    ipv4_enabled = true
    ipv6_enabled = true
  }
  network {
    network_id = hcloud_network.private_network.id
  }
  user_data = file("${path.module}/cloud-init-worker.yaml")

  depends_on = [hcloud_network_subnet.private_network_subnet, hcloud_server.master-node]
}
```

## Step 4 - Deploy your cluster

Now that you have your master and worker nodes you can simply run `terraform apply` to create the cluster.

```shell
terraform apply -var-file .tfvars
```

## Conclusion

Congratulations! You've just created your own scalable kubernetes cluster on Hetzner. You can now deploy your applications and scale them as you see fit. If you want to learn more about kubernetes, you can check out the [official documentation](https://kubernetes.io/docs/home/).

##### License: MIT

<!--

Contributor's Certificate of Origin

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I have
    the right to submit it under the license indicated in the file; or

(b) The contribution is based upon previous work that, to the best of my
    knowledge, is covered under an appropriate license and I have the
    right under that license to submit that work with modifications,
    whether created in whole or in part by me, under the same license
    (unless I am permitted to submit under a different license), as
    indicated in the file; or

(c) The contribution was provided directly to me by some other person
    who certified (a), (b) or (c) and I have not modified it.

(d) I understand and agree that this project and the contribution are
    public and that a record of the contribution (including all personal
    information I submit with it, including my sign-off) is maintained
    indefinitely and may be redistributed consistent with this project
    or the license(s) involved.

Signed-off-by: Alexandru Popescu (alexandru.popescu.fr@icloud.com)

-->