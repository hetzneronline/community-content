---
SPDX-License-Identifier: MIT
path: "/tutorials/nginx-password-protect-content"
slug: "nginx-password-protect-content"
date: "2021-09-26"
title: "Password Protecting Web Content in the Hetzner Cloud"
short_description: "This tutorial will walk you through the steps to secure content on an Nginx webserver with Node.js running in the Hetzner Cloud"
tags: ["nginx", "auth", "auth_request", "nodejs"]
author: "Barnabas Bucsy"
author_link: "https://github.com/theonethread"
author_img: "https://avatars.githubusercontent.com/u/7080741?v=4"
author_description: "code monk(ey)"
language: "en"
available_languages: ["en"]
header_img: "header-4"
cta: "cloud"
---

## Introduction

This tutorial will walk you through the steps to publish password protected content on an Nginx webserver with server-side Node.JS authentication in the [Hetzner Cloud](https://www.hetzner.com/cloud "Open") infrastructure.

**Prerequisites**

> _**NOTE:** This tutorial builds on the setup we created in [Setting Up a Secure Fedora Webserver in the Hetzner Cloud](https://community.hetzner.com/tutorials/secure-fedora-webserver "Open"), or similar._

* Hetzner account with access to Cloud and DNS Console
* Secure Fedora cloud instance
* Registered domain name with set up zone in DNS Console
* Nginx webserver set up with wildcard subdomain SSL certificate

## Step 1 - Nginx Configuration Refactor

Since we plan on serving multiple server blocks, to make configuration easier to maintain we will create some feature specific configuration files under `/etc/nginx/shared.d`.

```
$ mkdir -p /etc/nginx/shared.d
```

### Step 1.1 - Common HTTP Configuration

Create `/etc/nginx/shared.d/http.conf` with the following contents:

```
# Common HTTP server block directives

listen 80;
return 301 https://$host$request_uri;
```

> _**NOTE:** Although in the previous tutorial it was optional, here we disallow HTTP communication._

### Step 1.2 - Common HTTPS Configuration

Create `/etc/nginx/shared.d/https.conf` with the following contents:

```
# Common HTTPS server block directives

listen 443 ssl http2;
keepalive_timeout 70;
index index.html;
try_files $uri $uri/ =404;
ssl_dhparam /etc/ssl/certs/dhparam.pem;
ssl_protocols TLSv1.2;
ssl_prefer_server_ciphers on;
ssl_ciphers "EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4";
error_page 404 @error404;
error_page 500 502 503 504 @error50x;
```

### Step 1.3 - Common Authentication Configuration

Create `/etc/nginx/shared.d/auth.conf` with the following contents:

```
# Common authentication server block directives

auth_request /validate-token;
auth_request_set $memento_header_user $upstream_http_x_memento_user;
auth_request_set $memento_header_role $upstream_http_x_memento_role;
add_header X-Memento-User $memento_header_user;
add_header X-Memento-Role $memento_header_role;
error_page 401 = @error401;
error_page 403 = @error403;

location = /validate-token {
    internal;
    proxy_pass http://localhost:<auth-port>/api/v1/validate;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header Host $http_host:$server_port;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Original-URI $request_uri;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
```

This file basically tells, that every request of the server block using it must be validated through the `/validate-token` location, which is a proxy to our yet-to-be-created authentication service. It also decorates successful responses with two additional headers coming from the authentication service's response: `X-Memento-User` and `X-Memento-Role`. _Feel free to rename the headers and variables according to casing in the config._

### Step 1.4 - Refactor existing site settings

If you followed the previous tutorial, your site's configuration should be located at `/etc/nginx/sites-available/<your-domain>.conf`. We will delete all lines present in our common HTTP or HTTPS configs, and instead will include those configuration files. After the modifications it should look like this:

```
server {
    include /etc/nginx/shared.d/http.conf;

    server_name <your-domain> www.<your-domain>;
}

server {
    include /etc/nginx/shared.d/https.conf;

    server_name <your-domain> www.<your-domain>;
    root /var/www/<your-domain>/html;
    ssl_certificate /etc/letsencrypt/live/<your-domain>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<your-domain>/privkey.pem;

    location @error404 {
        return 303 /not-found.html?url=$scheme://$http_host$request_uri break;
    }

    location @error50x {
        return 303 /error.html?url=$scheme://$http_host$request_uri break;
    }
}
```

> _**NOTE:** Error page handling has changed, so if you created the `40x.html` and `50x.html` in `/var/www/<your-domain>/html`, rename them to `not-found.html` and `error.html` - later on you might want to use the search parameter too that lead the visitors here._

### Step 1.5 - Apply changes

Test your configuration, and if everything is ok restart the Nginx service:

```
$ nginx -t
$ service nginx restart
```

## Step 2 - Create Restricted Subdomain

Next we will create a `private.<your-domain>` subdomain, these contents will be password protected. We will make some exceptions, will allow error pages and favicon to be served, also the root `index.html`, which will serve as a login page, and our whole API (which is a rushed design decision, but this tutorial only serves as a skeleton for understanding concepts).

### Step 2.1 - Create Server Block

Create a configuration under `/etc/nginx/sites-available/` called `private.<your-domain>.conf` with the contents:

```
server {
    include /etc/nginx/shared.d/http.conf;

    server_name private.<your-domain>;
}

server {
    include /etc/nginx/shared.d/https.conf;
    include /etc/nginx/shared.d/auth.conf;

    server_name private.<your-domain>;
    root /var/www/private.<your-domain>/html;
    ssl_certificate /etc/letsencrypt/live/<your-domain>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<your-domain>/privkey.pem;

    location = / {
        auth_request off;
    }

    location = /index.html {
        auth_request off;
    }

    location = /not-found.html {
        auth_request off;
    }

    location = /error.html {
        auth_request off;
    }

    location = /favicon.ico {
        auth_request off;
    }

    location /api/ {
        auth_request off;
        proxy_pass http://localhost:9999/api/;
        proxy_set_header Host $http_host:$server_port;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location @error401 {
        return 303 /?status=401&url=$scheme://$http_host$request_uri;
    }

    location @error403 {
        return 303 /?status=403&url=$scheme://$http_host$request_uri;
    }

    location @error404 {
        return 303 /not-found.html?url=$scheme://$http_host$request_uri break;
    }

    location @error50x {
        return 303 /error.html?url=$scheme://$http_host$request_uri break;
    }
}
```

### Step 2.2 - Add Content

Create the directory for your contents:

```
mkdir -p /var/www/private.<your-domain>/html
```

Create the appropriate `not-found.html`, `error.html`, and an `index.html` with the contents:

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no, minimal-ui"
    />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta http-equiv="Content-Script-Type" content="text/javascript" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <title>{{your-domain}} - Home</title>
    <meta name="author" content="{{author}}" />
  </head>
  <body>
    <section>
      <pre id="loginTitle">{{your-domain}} - Login</pre>
      <form id="loginForm">
        <pre>Username: <input type="text" name="login" id="user" /></pre>
        <pre>Password: <input type="password" name="pass" id="pass" /></pre>
      </form>
      <button id="loginButton">Login</button>
      <button id="logoutButton">Logout</button>
      <pre id="loginStatus"></pre>
    </section>
  </body>
  <script>
    const form = document.getElementById("loginForm");
    const loginButton = document.getElementById("loginButton");
    const logoutButton = document.getElementById("logoutButton");
    const status = document.getElementById("loginStatus");
    loginButton.addEventListener("click", async () => {
      loginButton.disabled = true;
      logoutButton.disabled = true;
      const user = form.user.value;
      const pass = form.pass.value;
      form.pass.value = "";
      status.innerText = "Working...";
      const resp = await fetch(`https://${location.hostname}/api/v1/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ user, pass })
      });
      if (resp.ok) {
        redirectUrl = new URLSearchParams(window.location.search).get("url");
        if (redirectUrl) {
          document.location = redirectUrl;
        } else {
          loginButton.disabled = false;
          logoutButton.disabled = false;
          status.innerText = "Logged in.";
        }
      } else {
        loginButton.disabled = false;
        logoutButton.disabled = false;
        status.innerText = "Login failed.";
      }
    });
    logoutButton.addEventListener("click", async () => {
      loginButton.disabled = true;
      logoutButton.disabled = true;
      form.pass.value = "";
      status.innerText = "Working...";
      const resp = await fetch(`https://${location.hostname}/api/v1/logout`);
      if (resp.ok) {
        loginButton.disabled = false;
        logoutButton.disabled = false;
        status.innerText = "Logged out.";
      } else {
        loginButton.disabled = false;
        logoutButton.disabled = false;
        status.innerText = "Logout failed.";
      }
    });
  </script>
</html>
```

### Step 2.3 - Apply changes

To enable the subdomain create a symlink in your `sites-enabled` directory:

```
$ ln -s /etc/nginx/sites-available/private.<your-domain>.conf /etc/nginx/sites-enabled/private.<your-domain>.conf
```

Test your configuration, and if everything is ok restart the Nginx service:

```
$ nginx -t
$ service nginx restart
```

### Step 2.4 - Add DNS Zone Entry

Now we need to create a new DNS entry in the `<your-domain>` zone in [Hetzner DNS Console](https://dns.hetzner.com/ "Open"):

Just add a new `A` record called `private` with previously acquired server IP address as value. After the zone updated you should be able to access your (not-yet-functional) login form under `https://private.<your-domain>/`.

## Step 3 - Create Authentication Service

By this far our skeleton setup for `private.<your-domain>` server block uses 3 API endpoints:

* `/api/v1/login`
* `/api/v1/logout`
* `/api/v1/validate`












##### License: MIT

<!--

Contributor's Certificate of Origin

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I have
    the right to submit it under the license indicated in the file; or

(b) The contribution is based upon previous work that, to the best of my
    knowledge, is covered under an appropriate license and I have the
    right under that license to submit that work with modifications,
    whether created in whole or in part by me, under the same license
    (unless I am permitted to submit under a different license), as
    indicated in the file; or

(c) The contribution was provided directly to me by some other person
    who certified (a), (b) or (c) and I have not modified it.

(d) I understand and agree that this project and the contribution are
    public and that a record of the contribution (including all personal
    information I submit with it, including my sign-off) is maintained
    indefinitely and may be redistributed consistent with this project
    or the license(s) involved.

Signed-off-by: Barnabas Bucsy <barnabas.bucsy@gmail.com>

-->
