---
SPDX-License-Identifier: MIT
path: "/tutorials/nginx-password-protect-content"
slug: "nginx-password-protect-content"
date: "2021-09-26"
title: "Password Protecting Web Content in the Hetzner Cloud"
short_description: "This tutorial will walk you through the steps to secure content on an Nginx webserver with Node.js running in the Hetzner Cloud"
tags: ["nginx", "auth", "auth_request", "cors", "nodejs", "fastify"]
author: "Barnabas Bucsy"
author_link: "https://github.com/theonethread"
author_img: "https://avatars.githubusercontent.com/u/7080741?v=4"
author_description: "code monk(ey)"
language: "en"
available_languages: ["en"]
header_img: "header-4"
cta: "cloud"
---

## Introduction

This tutorial will walk you through the steps to publish password protected content on an Nginx webserver with server-side Node.JS authentication in the [Hetzner Cloud](https://www.hetzner.com/cloud "Open") infrastructure.

**Prerequisites**

> _**NOTE:** This tutorial builds on the setup we created in [Setting Up a Secure Fedora Webserver in the Hetzner Cloud](https://community.hetzner.com/tutorials/secure-fedora-webserver "Open"), or similar._

* Hetzner account with access to Cloud and DNS Console
* Secure Fedora cloud instance
* Registered domain name with set up zone in DNS Console
* Nginx webserver set up with wildcard subdomain SSL certificate

**NOTE for Commands on Remote**

All below commands assume you have root privileges, so with a user int the `wheel` group you will have to either run the commands with the `sudo` prefix, or act in the name of root user with the command:

```
$ su root -
```

## Step 1 - Nginx Configuration Refactor

Since we plan on serving multiple server blocks, to make configuration easier to maintain we will create some feature specific configuration files under `/etc/nginx/shared.d`.

```
$ mkdir -p /etc/nginx/shared.d
```

### Step 1.1 - Common HTTP Configuration

Create `/etc/nginx/shared.d/http.conf` with the following contents:

```
# Common HTTP server block directives

listen 80;
return 301 https://$host$request_uri;
```

> _**NOTE:** Although in the previous tutorial it was optional, here we disallow HTTP communication._

### Step 1.2 - Common HTTPS Configuration

Create `/etc/nginx/shared.d/https.conf` with the following contents:

```
# Common HTTPS server block directives

listen 443 ssl http2;
keepalive_timeout 70;
index index.html;
try_files $uri $uri/ =404;
ssl_dhparam /etc/ssl/certs/dhparam.pem;
ssl_protocols TLSv1.2;
ssl_prefer_server_ciphers on;
ssl_ciphers "EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4";
error_page 404 @error404;
error_page 500 502 503 504 @error50x;

location / {
    if ($http_origin ~ "^https://(.*\.)?<your-escaped-domain>(:[0-9]+)?$") {
        set $cors "trusted";
    }
    if ($request_method = "OPTIONS") {
        set $cors "${cors}-options";
    }
    if ($cors = "trusted-options") {
        add_header Access-Control-Allow-Origin $http_origin;
        add_header Access-Control-Allow-Credentials true;
        add_header Access-Control-Max-Age 1728000;
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS, DELETE, PUT";
        add_header Access-Control-Allow-Headers "User-Agent,Keep-Alive,Content-Type";
        return 204;
    }
    if ($cors = "trusted") {
        add_header Access-Control-Allow-Origin $http_origin;
        add_header Access-Control-Allow-Credentials true;
    }
}
```

> _**NOTE:** We enable Cross Origin Resource Sharing (CORS) between all our subdomains, for this to work we use a Regular Expression in the generic root `/` location, where `<your-escaped-domain>` should be your RegExp escaped domain (eg. `example.com` -> `example\.com`)! If you plan serving multiple high level domains on your server you should consider separating the generic root `/` location block (or parts of it) to a separate `.conf` file in a domain specific configuration directory - and include that later after common configurations._

### Step 1.3 - Common Authentication Configuration

Create `/etc/nginx/shared.d/auth.conf` with the following contents:

```
# Common authentication server block directives

auth_request /validate-token;
auth_request_set $custom_header_user $upstream_http_x_custom_user;
auth_request_set $custom_header_role $upstream_http_x_custom_role;
add_header X-Custom-User $custom_header_user;
add_header X-Custom-Role $custom_header_role;

location = /validate-token {
    internal;
    proxy_pass http://localhost:<auth-port>/api/v1/validate;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header Host $http_host:$server_port;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Original-URI $request_uri;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}

error_page 401 = @error401;
error_page 403 = @error403;
```

This file basically tells, that every request of the server block using it must be validated through the `/validate-token` internal location, which is a proxy to our yet-to-be-created authentication service. It also decorates successful responses with two additional headers coming from the authentication service's response: `X-Custom-User` and `X-Custom-Role`.

> _**NOTE:** If you plan serving multiple high level domains on your server you should consider separating the `/validate-token` location block (or parts of it) to a separate `.conf` file in a domain specific configuration directory - and include that later after common configurations._

### Step 1.4 - Refactor existing site settings

If you followed the previous tutorial, your site's configuration should be located at `/etc/nginx/sites-available/<your-domain>.conf`. We will delete all lines present in our common HTTP or HTTPS configs, and instead will include those configuration files. We will also set up basic CORS handling in our server block's root location. After the modifications it should look like this:

```
server {
    include /etc/nginx/shared.d/http.conf;

    server_name <your-domain> www.<your-domain>;
}

server {
    include /etc/nginx/shared.d/https.conf;

    server_name <your-domain> www.<your-domain>;
    root /var/www/<your-domain>/html;
    ssl_certificate /etc/letsencrypt/live/<your-domain>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<your-domain>/privkey.pem;

    location @error404 {
        return 303 https://<your-domain>/not-found.html?url=$scheme://$http_host$request_uri break;
    }

    location @error50x {
        return 303 https://<your-domain>/error.html?url=$scheme://$http_host$request_uri break;
    }

    location @error401 {
        return 303 https://private.<your-domain>/?status=401&url=$scheme://$http_host$request_uri;
    }

    location @error403 {
        return 303 https://private.<your-domain>/?status=403&url=$scheme://$http_host$request_uri;
    }
}
```

> _**NOTE:** Error page handling has changed, so if you created the `40x.html` and `50x.html` in `/var/www/<your-domain>/html`, rename them to `not-found.html` and `error.html` - later on you might want to use the search parameter too that lead the visitors here._

The extra `@error401` and `@error403` locations redirect credential errors to our `private.<your-domain>` server block's root to later enforce login.

### Step 1.5 - Apply changes

Test your configuration, and if everything is ok restart the Nginx service:

```
$ nginx -t
$ service nginx restart
```

## Step 2 - Create Restricted Subdomain

Next we will create a `private.<your-domain>` subdomain, these contents will be password protected. We will make some exceptions, will allow error pages and favicon to be served, also the root `index.html`, which will serve as a login page, and our whole API (which currently only serves as a skeleton for understanding concepts).

### Step 2.1 - Create Server Block

Create a configuration under `/etc/nginx/sites-available/` called `private.<your-domain>.conf` with the contents:

```
server {
    include /etc/nginx/shared.d/http.conf;

    server_name private.<your-domain>;
}

server {
    include /etc/nginx/shared.d/https.conf;
    include /etc/nginx/shared.d/auth.conf;

    server_name private.<your-domain>;
    root /var/www/private.<your-domain>/html;
    ssl_certificate /etc/letsencrypt/live/<your-domain>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<your-domain>/privkey.pem;

    location = / {
        auth_request off;
    }

    location = /index.html {
        auth_request off;
    }

    location = /favicon.ico {
        auth_request off;
    }

    location /api/ {
        auth_request off;
        proxy_pass http://localhost:9999/api/;
        proxy_set_header Host $http_host:$server_port;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location @error401 {
        return 303 https://private.<your-domain>/?status=401&url=$scheme://$http_host$request_uri;
    }

    location @error403 {
        return 303 https://private.<your-domain>/?status=403&url=$scheme://$http_host$request_uri;
    }

    location @error404 {
        return 303 https://<your-domain>/not-found.html?url=$scheme://$http_host$request_uri break;
    }

    location @error50x {
        return 303 https://<your-domain>/error.html?url=$scheme://$http_host$request_uri break;
    }
}
```

This file makes everything protected under the `private.<your-domain>` server block, but later we explicitly expose our favicon, the root (where we plan to have a login page), and our whole API. Also, we set up redirect rules to the main site when hitting server errors, or not finding content, but redirect credential errors to our server block's root to enforce login.

### Step 2.2 - Add Content

Create the directory for your contents:

```
mkdir -p /var/www/private.<your-domain>/html
```

Create an `index.html` inside it with the contents:

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no, minimal-ui"
    />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta http-equiv="Content-Script-Type" content="text/javascript" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <title>{{your-domain}} - Home</title>
    <meta name="author" content="{{author}}" />
  </head>
  <body>
    <section>
      <pre id="loginTitle">{{your-domain}} - Login</pre>
      <form id="loginForm">
        <pre>Username: <input type="text" name="login" id="user" /></pre>
        <pre>Password: <input type="password" name="pass" id="pass" /></pre>
      </form>
      <button id="loginButton">Login</button>
      <button id="logoutButton">Logout</button>
      <pre id="loginStatus"></pre>
    </section>
  </body>
  <script>
    const form = document.getElementById("loginForm");
    const loginButton = document.getElementById("loginButton");
    const logoutButton = document.getElementById("logoutButton");
    const status = document.getElementById("loginStatus");
    const enableUi = (statusText = "") => {
      loginButton.disabled = false;
      logoutButton.disabled = false;
      status.innerText = statusText;
    };
    const disableUi = () => {
      loginButton.disabled = true;
      logoutButton.disabled = true;
      status.innerText = "Working...";
      const ret = { user: form.user.value, pass: form.pass.value };
      form.pass.value = "";
      return ret;
    };
    loginButton.addEventListener("click", async () => {
      const resp = await fetch("https://private.{{your-domain}}/api/v1/login", {
        method: "POST",
        redirect: "error",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(disableUi())
      }).catch((err) => enableUi("Login failed.\n" + err));
      if (resp?.ok) {
        redirectUrl = new URLSearchParams(window.location.search).get("url");
        if (redirectUrl) {
          document.location = redirectUrl;
        } else {
          enableUi("Logged in.");
        }
      } else {
        enableUi("Login failed.");
      }
    });
    logoutButton.addEventListener("click", async () => {
      disableUi();
      const resp = await fetch("https://private.{{your-domain}}/api/v1/logout", {
        redirect: "error"
      }).catch((err) => enableUi("Logout failed.\n" + err));
      if (resp?.ok) {
        enableUi("Logged out.");
      } else {
        enableUi("Logout failed.");
      }
    });
  </script>
</html>
```

> _**NOTE:** The placeholders to replace in this file are `{{your-domain}}` and `{{author}}`._

This is a really basic page, the file has two sections:

* The `<body>` part creates a basic login form with appropriate buttons and status text.
* The `<script>` part handles the login logic and communication with our publicly exposed API.

> _**NOTE:** Since we know that only errors will get redirected, we use the `redirect: "error"` option when fetching the API response, not to confuse a successfully redirected error page as false positive._

### Step 2.3 - Apply changes

To enable the subdomain create a symlink in your `sites-enabled` directory:

```
$ ln -s /etc/nginx/sites-available/private.<your-domain>.conf /etc/nginx/sites-enabled/private.<your-domain>.conf
```

Test your configuration, and if everything is ok restart the Nginx service:

```
$ nginx -t
$ service nginx restart
```

### Step 2.4 - Add DNS Zone Entry

Now we need to create a new DNS entry in the `<your-domain>` zone in [Hetzner DNS Console](https://dns.hetzner.com/ "Open"):

Just add a new `A` record called `private` with previously acquired server IP address as value. After the zone updated you should be able to access your (not-yet-functional) login form under `https://private.<your-domain>/`.

## Step 3 - Create Authentication Service

By this far our skeleton setup for `private.<your-domain>` server block uses 3 internal API endpoints:

* `http://localhost:9999/api/v1/login` called from our login page (through `private.<your-domain>/api/` proxy)
* `http://localhost:9999/api/v1/logout` called from our login page (through `private.<your-domain>/api/` proxy)
* `http://localhost:9999/api/v1/validate` called from any protected content as Nginx authentication preflight request (through internal `/validate-token` proxy)

Next we need to create the actual backend service, that can handle these requests. We will be doing it in [Node.js](https://nodejs.org/ "Open") with the help of the [Fastify](https://www.fastify.io/ "Open") web framework.

### Step 3.1 - Install Node.js
















##### License: MIT

<!--

Contributor's Certificate of Origin

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I have
    the right to submit it under the license indicated in the file; or

(b) The contribution is based upon previous work that, to the best of my
    knowledge, is covered under an appropriate license and I have the
    right under that license to submit that work with modifications,
    whether created in whole or in part by me, under the same license
    (unless I am permitted to submit under a different license), as
    indicated in the file; or

(c) The contribution was provided directly to me by some other person
    who certified (a), (b) or (c) and I have not modified it.

(d) I understand and agree that this project and the contribution are
    public and that a record of the contribution (including all personal
    information I submit with it, including my sign-off) is maintained
    indefinitely and may be redistributed consistent with this project
    or the license(s) involved.

Signed-off-by: Barnabas Bucsy <barnabas.bucsy@gmail.com>

-->
