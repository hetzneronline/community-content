---
SPDX-License-Identifier: MIT
path: "/tutorials/ubuntu-virtualisation-with-quemu-bridged/de"
slug: "ubuntu-virtualisation-with-quemu-bridged"
date: "2025-10-31"
title: "Einrichten einer bridged IPv4 und IPv6 in Ubuntu für die Virtualisierung mit QEMU"
short_description: "Dieses Tutorial erklärt, wie man einen Host mit einer virtuellen Maschine (Gast) im gleichen Subnetz verbindet."
tags: ["IPv4", "IPv6", "QEMU", "Virtualisation", "Ubuntu"]
author: "VinkPa"
author_link: "https://github.com/VinkPa"
author_img: "https://avatars.githubusercontent.com/u/225162162"
author_description: ""
language: "de"
available_languages: ["en", "de"]
header_img: "header-6"
cta: "dedicated"
---

## Einführung

In diesem Tutorial lernst du, wie du ein Netzwerk-Setup einrichtest, bei dem der Host und eine virtuelle Maschine (Gast) über eine gemeinsame Bridge im gleichen Subnetz verbunden sind. Am Ende sollte die Konfiguration in etwa so aussehen:

<table style="background-color: transparent; border: none; min-width: 37rem;">

<tr><td style="border: none;vertical-align: top;">
        HOST:<ul>
            <li>behält seine Haupt-IPv4-Adresse</li>
            <li>bekommt IPv6::2/64</li>
            </ul>
        </td>
    <td style="border: none;vertical-align: top;">
        GAST:<ul>
            <li>kriegt die zusätzliche einzelne IPv4-Adresse im Bridged-Modus</li>
            <li>kein IPv6, weil das Subnetz der Haupt-IPv4-Adresse zugewiesen ist</li>
            </ul>
        </td>
    </tr>

</table>

Um das zu erreichen, wird eine virtuelle Bridge eingerichtet, die die Hauptschnittstelle übernimmt (gebridget zu `enp7s0`).

Informationen zu einem gerouteten Setup (Host und Gast in unterschiedlichen Subnetzen), gibt es in [diesem Tutorial](/tutorials/ubuntu-virtualisation-with-quemu-routed/de).

**Voraussetzungen**

- Der Server hat 1 physische Uplink-Schnittstelle – `enp7s0` mit der MAC-Adresse `AA:BB:CC:DD:EE:FF`
- Der Server hat eine Haupt-IPv4-Adresse (`enp7s0`)
- Der Server hat eine zusätzliche einzelne IPv4-Adresse (die virtuelle MAC-Adresse `00:50:56:00:11:22` wurde schon über das Robot-Konto zugewiesen)
- Der Server hat ein `/64` IPv6-Subnetz für den HOST
- In diesem Beispielszenario verwenden wir reguläres qemu in der Konsole

**Beispiel-Benennungen**

```bash
2001:db8:1234::   # Placeholder for public IPv6 network of the server
10.0.0.168        # Placeholder for main IPv4
10.0.10.135       # Placeholder for additional single IPv4
10.10.10.128/29   # Placeholder for additional IPv4 Network
AA:BB:CC:DD:EE:FF # Placeholder for MAC address of physical interface and main IPv4
00:50:56:00:11:22 # Placeholder for virtual MAC address of additional single IP address
```

<br>

**Hinweis**: Der im Beispiel gezeigte Startbefehl dient nur zur Veranschaulichung und stellt keine Anleitung dar.

## Schritt 1 – Netplan auf HOST konfigurieren

```bash
nano /etc/netplan/01-netcfg.yaml
```

```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enp7s0:
      dhcp4: no
      dhcp6: no
  bridges:
    vibr0:
      interfaces: [enp7s0]
      macaddress: AA:BB:CC:DD:EE:FF # MAC address of the physical network interface of the HOST uplink
      addresses:
        - 10.0.0.168/32          # Main IPv4 for the HOST
        - 2001:db8:1234::2/64    # Main IPv6/64 subnet for the HOST
                                 # Additional IP for the VM is not configured on HOST
      routes:
        - on-link: true
          to: 0.0.0.0/0
          via: 10.0.0.129        # Gateway IPv4 of the main IPv4 address
        - to: default
          via: fe80::1           # Default Hetzner IPv6 gateway
      nameservers:
        addresses:
          - 185.12.64.2          # Nameservers from installimage process
          - 2a01:4ff:ff00::add:1 # Nameservers from installimage process
          - 185.12.64.1          # Nameservers from installimage process
          - 2a01:4ff:ff00::add:2 # Nameservers from installimage process
```

## Schritt 2 – Tap-Schnittstelle auf HOST einrichten

Führe folgende Befehle aus, um HOST und GUEST zu verbinden.

> Diese Einstellung bleibt nach einem Neustart nicht erhalten.

```bash
ip tuntap add dev tap0 mode tap user $(whoami)
ip link set tap0 up
ip link set tap0 master vibr0
```

Um dies dauerhaft zu machen, kannst du eine Servicedatei verwenden:

```bash
nano /etc/systemd/system/tap0.service
```

```ini
[Unit]
Description=Persistent tap0 interface
After=network-pre.target
Before=network.target
Wants=network.target

[Service]
Type=oneshot
ExecStart=/usr/sbin/ip tuntap add dev tap0 mode tap user root
ExecStartPost=/usr/sbin/ip link set tap0 up
ExecStartPost=/usr/sbin/ip link set tap0 master vibr0
ExecStop=/usr/sbin/ip link set tap0 down
ExecStopPost=/usr/sbin/ip tuntap del dev tap0 mode tap
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
```

```bash
systemctl daemon-reload
systemctl enable tap0.service
```

Wichtiger Hinweis: Im Service-Beispiel wird der Benutzer „root“ definiert. Bitte passe den Benutzer so an, dass er mit dem Benutzer übereinstimmt, der die VM später in der Produktion ausführen wird.
**Mögliche Änderung:? Bitte ändere den Benutzer zu der Person, die in Zukunft Root sein soll.** 

## Schritt 3 – VM starten

```bash
qemu-system-x86_64 \
  -enable-kvm \
  -smp 4            `### 4 CPU cores` \
  -m 4096           `### 4GB RAM` \
  -cpu host         `### Use the native CPU architecture` \
  -hda vm0.vpc      `### Virtual HDD file for the OS in this case` \
  -usbdevice tablet `### Emulate USB tablet for HID input (optional)` \
  -k en-us          `### Keyboard layout (optional)` \
  -vnc 127.0.0.1:1  `### Launch VNC for visualistation (optional) - Please set up an encrypted tunnel to not expose the unencrypted VNC connection!` \
  -monitor stdio    `### Launch qemu in interactive mode - Allow adjustments to the VM on the fly)` \
  -netdev tap,id=net0,ifname=tap0,script=no,downscript=no   `### Assign a network device to the VM via the tap0 you created earlier` \
  -device virtio-net-pci,netdev=net0,mac=00:50:56:00:11:22  `### Directly start the VM with the correct virtual MAC to prevent abuse due to unallowed mac`
```

## Schritt 4 – netplan von GUEST konfigurieren

```bash
nano /etc/netplan/01-netcfg.yaml
```

```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    ens3:                           # Network identifier of the VM according to predictable naming scheme
      macaddress: 00:50:56:00:11:22 # MAC address of the physical network interface of the HOST uplink
      addresses:
        - 10.0.10.135/32            # The single IPv4 dddress for the GUEST
                                    # No IPv6 - IPv6 net is assigned to physical mac address
      routes:
        - to: default               # Default 0.0.0.0/0 route
          via: 10.0.0.129           # Gateway of the single IPv4
          on-link: true             # Required for IPv4/32 configuration
      nameservers:
        addresses:
          - 185.12.64.1             # Nameservers from installimage process
          - 185.12.64.2             # Nameservers from installimage process
```

Die Bridged-Konfiguration lässt es nicht zu, dass das Haupt-IPv6-/64-Subnetz sowohl auf dem Host als auch in der VM genutzt wird. Das IPv6-Subnetz wird über seine eindeutige MAC-Adresse genau an eine IPv4-Adresse weitergeleitet. Du kannst das Routing-Ziel in deinem Robot-Konto ändern.

Melde dich bei deinem Hetzner Robot-Konto an. Geh dann zu „Server“ > [wähle deinen Server aus] > „IPs“.

Sobald du mindestens 2 IPv4-Adressen mit einer zugewiesenen MAC-Adresse hast, siehst du hinter dem IPv6-Subnetz einen kleinen Button, mit dem du eine Ziel-MAC-Adresse festlegen kannst. Wenn du diese auf deine zusätzliche IPv4-Adresse einstellst, kannst du dein IPv6-Subnetz in deinem GUEST verwenden, aber nicht mehr auf dem HOST.

## Ergebnis

Nach Abschluss dieser Schritte sind Host und virtuelle Maschine erfolgreich über eine Bridge verbunden und befinden sich im selben Subnetz.
Der Host behält seine Haupt-IPv4-Adresse und erhält eine eigene IPv6-Adresse aus dem /64-Subnetz, während der Gast eine separate IPv4-Adresse über die Bridge nutzt.
Das Setup ermöglicht eine direkte Kommunikation zwischen Host und Gast ohne zusätzliche Routing-Konfiguration.


##### License: MIT

<!--

Contributor's Certificate of Origin

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I have
    the right to submit it under the license indicated in the file; or

(b) The contribution is based upon previous work that, to the best of my
    knowledge, is covered under an appropriate license and I have the
    right under that license to submit that work with modifications,
    whether created in whole or in part by me, under the same license
    (unless I am permitted to submit under a different license), as
    indicated in the file; or

(c) The contribution was provided directly to me by some other person
    who certified (a), (b) or (c) and I have not modified it.

(d) I understand and agree that this project and the contribution are
    public and that a record of the contribution (including all personal
    information I submit with it, including my sign-off) is maintained
    indefinitely and may be redistributed consistent with this project
    or the license(s) involved.

Signed-off-by: [Vincent Paßler]

-->
