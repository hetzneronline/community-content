---
SPDX-License-Identifier: MIT
path: "/tutorials/hetzner-ddns-bridge"
slug: "hetzner-ddns-bridge"
date: "2025-12-02"
title: "Hetzner DynDNS Bridge: Console- und KonsoleH-API"
short_description: "Ein PHP-/SQLite-Skript, das Hetzner-DNS-Zonen über KonsoleH und die neue Console-API synchron hält."
tags: ["Hetzner DNS", "Hetzner Cloud", "Automation", "PHP"]
author: "woehrl"
author_link: "https://github.com/woehrl"
author_img: "https://avatars.githubusercontent.com/u/7691653"
author_description: "S/W Architect, Full-Stack Senior Developer"
language: "de"
available_languages: ["de", "en"]
header_img: "header-x"
cta: "product"
---

## Einführung

Deine IPv4/IPv6 soll folgen wie ein treuer Hund, ohne dass du DNS von Hand pflegen musst? Dieses kleine PHP-Skript spielt DynDNS-Server, spricht sowohl die Hetzner Console DNS API als auch die klassische KonsoleH DNS API und versteht sich mit Routern wie einer Fritz!Box. Zuerst kommt die Schritt-für-Schritt-Anleitung für Einsteiger, danach die Nerd-Ecke mit den Details.

## Was du brauchst

- Ein Hetzner-Account mit mindestens einer DNS-Zone (Console oder KonsoleH).
- PHP mit den Erweiterungen `curl` und `SQLite3` (Webspace oder kleiner VM reicht).
- Einen Ort für das PHP-Skript und einen Cronjob alle paar Minuten.
- Einen Client, der eine DynDNS-URL aufrufen kann (Router, NAS oder ein einfacher curl-Aufruf).

## Schnellstart: von null zum funktionierenden Update

### 1) Dateien besorgen

- Lade das Projekt aus dem offiziellen Repository (https://github.com/woehrl/hetzner-dyndns/, per Clone oder ZIP) und lege es auf deinem Webspace oder einer kleinen VM ab.
- Du brauchst mindestens `hetzner_dyndns.php`, `hetzner_dyndns.config.php.dist` und die `.htaccess`.

### 2) Config anlegen

```bash
cp hetzner_dyndns.config.php.dist hetzner_dyndns.config.php
```

Bearbeite `hetzner_dyndns.config.php`:

- Setze `script_password` auf ein starkes, geteiltes Passwort. Dein Router nutzt es.
- Lege fest, welche API zuerst probiert wird: `api_order` auf `['console', 'dns']` für Migration oder `['console']`, wenn alle Zonen auf der neuen API liegen.
- Tokens hinzufügen:
  - Console: Erstelle ein DNS-API-Token in der Hetzner Cloud Console und trage es bei `console_token` ein.
  - KonsoleH: Erstelle ein DNS-Token in KonsoleH und trage es bei `dns_token` ein (nur wenn du dort noch Zonen hast).
- Optional: Wähle ein `auth_realm` (z. B. "dynbridge").
- Optional: Zeige `history_db` auf einen beschreibbaren Pfad (z. B. `__DIR__ . '/hetzner_dyndns.sqlite3'`).
- Optional: Passe die TTL pro Realm an, wenn es schneller oder langsamer propagieren soll.

### 3) Sicher ins Netz stellen

- Halte `hetzner_dyndns.config.php` aus öffentlichen Repos und Verzeichnislisten heraus.
- Stelle sicher, dass `.htaccess` die DynDNS-Endpunkte auf das Skript umschreibt, damit alte Clients funktionieren:

```apache
RewriteEngine On
RewriteRule ^(nic/update|v3/update)$ hetzner_dyndns.php [L,QSA]
```

- Falls nötig, sorge dafür, dass der PHP-User in die SQLite-Datei und das Debug-Log schreiben darf.

### 4) Update testen

- Baue die Test-URL (ersetze Domain und Host):

```
https://dein-ddns-host.example.com/nic/update?hostname=myhost.example.com&myip=203.0.113.10
```

- Nutze HTTP Basic Auth. DynDNS-Clients senden meist irgendeinen Usernamen plus das Passwort aus `script_password`; per `curl` geht es so:

```bash
curl -u user:deinPasswort \
  "https://dein-ddns-host.example.com/nic/update?hostname=myhost.example.com&myip=$(curl -s ifconfig.me)"
```

- Glückliche Antworten sind `good <ip>` (aktualisiert) oder `nochg <ip>` (nichts zu tun). Alles andere: ins Debug-Log schauen.

### 5) Automatisieren

- Cron alle 5 Minuten (nach Bedarf anpassen):

```bash
*/5 * * * * php /path/to/hetzner_dyndns.php --cron --realm=default
```

- Richte deinen Router oder dein NAS auf dieselbe `nic/update`-URL mit dem gesetzten Passwort ein. IPv6 klappt, wenn der Client `myipv6` mitsendet.

### 6) Kurzer Troubleshooting-Spickzettel

- 401 oder Auth-Prompt: Passwort stimmt nicht oder `.htaccess` greift nicht.
- `not_found`: falsche Zone oder Hostname, oder fehlende Token-Rechte.
- SQLite-Schreibfehler: Dateirechte anpassen oder DB in einen beschreibbaren Pfad verschieben.
- Nichts ändert sich: `api_order` prüfen und das richtige Token pro Realm setzen.

## Nerd-Ecke (so funktioniert es wirklich)

### Architektur im Überblick

- Ein PHP-Skript, eine Config, eine SQLite-DB. DynDNS-Aufrufe (`/nic/update` oder `/v3/update`) werden via `.htaccess` auf `hetzner_dyndns.php` umgeschrieben.
- Das Skript authentifiziert mit deinem Passwort, parst Hostname und optionales `realm`, cached bekannte Records in SQLite und antwortet sofort mit `good`, wenn sich nichts geändert hat.

### Konfig-Details

- Gemeinsame Einstellungen: `script_password`, `auth_realm`, `history_db` sowie optional `debug`/`debug_log`.
- Benachrichtigungen: `notifications.enabled` aktivieren, `php` oder `smtp` wählen, Empfänger setzen und entscheiden, ob bei Erfolg, Fehler oder beidem gemailt wird.
- Realms: pro Realm `ttl`, `api_order`, `zone_name`, `console_token` und `dns_token`. Setze `zone_name`, wenn der DynDNS-Endpunkt auf einer Subdomain liegt, du aber die Hauptzone aktualisierst.

### Console-API-Ablauf (aktuell)

1. Zone über `/zones?name=<zone>` mit dem Console-DNS-Token finden.
2. RRsets über `/zones/{id}/rrsets` (A und AAAA) holen.
3. RRset-Namen mit dem Host abgleichen (inkl. `@` am Apex).
4. `set_records` aufrufen, um die IPs zu ersetzen. Erfolgreich = Action-Response; Fehler melden `not_found` oder fehlende Rechte.

### KonsoleH-DNS-API-Ablauf (Legacy)

1. Zonen-ID mit `/zones?name=<zone>` über `dns_token` holen.
2. A/AAAA-Record-IDs finden, in SQLite cachen und per `PUT /records/{id}` aktualisieren.
3. Fehler bleiben als `needs_sync` für Cron-Retries markiert.

### Wechsel zwischen den APIs

- Nutze `['console', 'dns']` während der Migration. Wenn Console `not_found` sagt, fällt das Skript auf KonsoleH zurück.
- Wenn eine Zone komplett auf Console läuft, `dns_token` entfernen oder auf `['console']` umstellen, um Legacy-Calls zu sparen.
- Nach Config-Änderungen `php hetzner_dyndns.php --cron` ausführen, um offene Jobs abzuarbeiten und beide APIs zu testen.

### Mehrere Zonen und Realms

- Lege pro Zone oder Subdomain einen Realm an. Beispiel: Realm `gjsi.de` und `ddns.gjsi.de` mit unterschiedlichen Tokens und TTLs.
- Nutze `realm=<name>` im DynDNS-Query-String, wenn du mehrere Domains über denselben Endpunkt bedienst.
- Der optionale CLI-Helfer `hetzner_dyndns_listhosts.php` kann gecachte IPv4/IPv6 pro Realm ausgeben, ohne den HTTP-Endpunkt zu treffen.

### Benachrichtigungen und Observability

- E-Mails zu Erfolgen und Fehlern über PHP `mail()` oder SMTP.
- `debug` und `debug_log` zeichnen Requests und Responses beider APIs plus Benachrichtigungsstatus auf.
- Cron-Summen listen Gesamtzahl, Erfolge, Fehler und welche API jeden Host bearbeitet hat.

### Sicherheit und Deployment

- `.htaccess` blockiert direkte Zugriffe auf PHP und SQLite und lässt nur die DynDNS-Endpunkte durch.
- Tokens nur auf DNS scopen und regelmäßig rotieren.
- SQLite-DB und Debug-Log müssen für den PHP-User schreibbar sein; nach Möglichkeit außerhalb öffentlicher Webroots ablegen.
- DynDNS-Endpunkt per HTTPS bereitstellen. Reines HTTP würde dein Passwort verraten.

## Fazit

Die Bridge liefert dir einen freundlichen DynDNS-Endpunkt, der Hetzners API-Umstellung überlebt. Starte mit dem Schnellstart, damit Updates laufen, und wirf dann einen Blick in die Nerd-Ecke, wenn du Realms, Benachrichtigungen oder das Console/KonsoleH-Verhältnis feintunen willst.

##### License: MIT

<!--

Contributor's Certificate of Origin

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I have
    the right to submit it under the license indicated in the file; or

(b) The contribution is based upon previous work that, to the best of my
    knowledge, is covered under an appropriate license and I have the
    right under that license to submit that work with modifications,
    whether created in whole or in part by me, under the same license
    (unless I am permitted to submit under a different license), as
    indicated in the file; or

(c) The contribution was provided directly to me by some other person
    who certified (a), (b) or (c) and I have not modified it.

(d) I understand and agree that this project and the contribution are
    public and that a record of the contribution (including all personal
    information I submit with it, including my sign-off) is maintained
    indefinitely and may be redistributed consistent with this project
    or the license(s) involved.

Signed-off-by: Florian Woehrl <fw@woehrl.biz>

-->
