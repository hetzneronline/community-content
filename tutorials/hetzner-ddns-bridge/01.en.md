---
SPDX-License-Identifier: MIT
path: "/tutorials/hetzner-ddns-bridge"
slug: "hetzner-ddns-bridge"
date: "2025-12-02"
title: "Hetzner DynDNS Bridge: Hetzner Console + DNS Console API Support"
short_description: "How to use a PHP/SQLite-based bridge that keeps Hetzner DNS zones in sync via the APIs of DNS Console API (legacy) and Hetzner Console API."
tags: ["Hetzner DNS", "Hetzner Cloud", "Automation", "PHP"]
author: "woehrl"
author_link: "https://github.com/woehrl"
author_img: "https://avatars.githubusercontent.com/u/7691653"
author_description: "S/W Architect, Full-Stack Senior Developer"
language: "en"
available_languages: ["en", "de"]
header_img: "header-6"
cta: "product"
---

## Introduction

Need your IPv4/IPv6 address to follow you around the internet without babysitting your DNS? This tutorial walks you through a small PHP script that pretends to be a DynDNS server, speaks to both [Hetzner Console](https://console.hetzner.com/) API and the legacy [DNS Console](https://dns.hetzner.com/) API, and plays nice with routers like a Fritz!Box. The first half is a hand-holding setup guide. The second half is the nerd zone with all the gory details. New DNS zones can no longer be created in DNS Console (as of 10 Nov 2025); plan to migrate every zone to Hetzner Console and only keep DNS Console enabled while you finish that move.

**Prerequisites**

- A Hetzner account with at least one DNS zone (Hetzner Console or DNS Console during migration).
- PHP with the `curl` and `SQLite3` extensions (typical web hosting or a small VM works fine).
- Somewhere to drop a PHP file and run cron every few minutes.
- A client that can call a DynDNS-style URL (router, NAS, or a simple curl command).

## Step 0 - Minimalistic example setup on Debian/Ubuntu

If you start from a fresh minimal Debian/Ubuntu host, this gets you to a working test endpoint:

* **Install prerequisites and add directory for scripts**  
  ```bash
  sudo apt update
  sudo apt install -y apache2 libapache2-mod-php php-cli php-curl php-sqlite3
  sudo a2enmod rewrite
  
  sudo mkdir -p /var/www/hetzner-ddns
  sudo chown -R www-data:www-data /var/www/hetzner-ddns
  ```

<br>

* **Create a minimal Apache site**  
  > Replace the value of `ServerName` with your DynDNS endpoint. Use HTTPS in production (Let's Encrypt works fine).
  
  ```bash
  cat <<'EOF' | sudo tee /etc/apache2/sites-available/hetzner-ddns.conf
  <VirtualHost *:80>
      ServerName ddns.example.com
      DocumentRoot /var/www/hetzner-ddns
      <Directory /var/www/hetzner-ddns>
          AllowOverride All
          Require all granted
      </Directory>
  </VirtualHost>
  EOF
  ```

<br>

* **Enable site**
  ```bash
  sudo a2ensite hetzner-ddns
  sudo apachectl configtest
  sudo systemctl reload apache2
  ```

## Step 1 - Grab the files

Use the files bundled with this tutorial in `tutorials/hetzner-ddns-bridge/scripts`:

> <small>Mirrored from https://github.com/woehrl/hetzner-dyndns, commit `11582e6`</small>

* [GitHub » tutorials/hetzner-ddns-bridge/scripts](https://github.com/hetzneronline/community-content/tree/master/tutorials/hetzner-ddns-bridge/scripts)

Copy the files to your web space or small VM. If you use the minimalistic example setup above, you need to save the files in `/var/www/hetzner-ddns`.

You need at least:

```shell
/var/www/hetzner-ddns
├─ hetzner_dyndns.php
├─ hetzner_dyndns.config.php.dist
├─ .htaccess                         The one provided on GitHub
└─ hetzner_dyndns_listhosts.php      Optional
```

Example commands:

```bash
export path="https://raw.githubusercontent.com/woehrl/hetzner-dyndns/refs/heads/main"
cd /var/www/hetzner-ddns

# Run this in the terminal to set the filenames
files=(
  hetzner_dyndns.php
  hetzner_dyndns.config.php.dist
  .htaccess
  hetzner_dyndns_listhosts.php
)

# Run this in the terminal to copy the files
for f in "${files[@]}"; do
  curl "$path/$f" | sudo tee "$f" >/dev/null
done
```

## Step 2 - Create your config

```bash
sudo cp hetzner_dyndns.config.php.dist hetzner_dyndns.config.php
```

Edit `hetzner_dyndns.config.php`:

|    | Description |
| -- | ----------- |
| <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">auth_user</kbd> | Optional: Username for HTTP Basic Auth. If empty, it defaults to <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">update</kbd>. |
| <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">auth_password</kbd> | Set a strong shared password. Your router will use this. |
| <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">api_order</kbd> | Decide which API to try first: set to <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">['console', 'dns']</kbd> for a smooth migration or <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">['console']</kbd> once every zone is on the new API. |
| <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">console_token</kbd><br><kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">dns_token</kbd> | Add tokens:<ul><li><b>Hetzner Console:</b> create a API token in the Hetzner Console and paste it into <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">console_token</kbd>.</li><li><b>DNS Console</b> (legacy): create a DNS token in DNS Console and paste it into <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">dns_token</kbd> (only if you still host zones there).</li></ul> |
| <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">zone_name</kbd> | If you want to update the IP address of a subdomain (e.g. `sub.example.com`), specify the parent domain (e.g. `example.com`) here. |
| <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">auth_realm</kbd> | Optionally: Pick a label (anything friendly like "dynbridge"). |
| <kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">history_db</kbd> | Optionally: Point to a writable path (for example<br><kbd style="background-color:#e2e2e2!important;color:#000;border-radius:6px;">__DIR__ . '/hetzner_dyndns.sqlite3'</kbd>). |
| TTL | Optionally: Adjust TTL per realm if you want faster or slower propagation. |

## Step 3 - Put it on the internet (safely)

- Keep `hetzner_dyndns.config.php` out of public Git and file listings.
- Ensure `.htaccess` rewrites DynDNS endpoints to the script so old clients work:
  ```apache
  RewriteEngine On
  RewriteRule ^(nic/update|v3/update)$ hetzner_dyndns.php [L,QSA]
  ```
- If your host needs it, set the PHP user to be able to write the SQLite file and debug log.

## Step 4 - Test an update

- Build the test URL (substitute your domain and desired host):
  ```https
  https://your-ddns-host.example.com/nic/update?hostname=myhost.example.com&myip=203.0.113.10
  ```
- Use HTTP Basic Auth with your `auth_user`/`auth_password` (user defaults to `update` if empty). Most DynDNS clients send any username plus the password, and you can also `curl` it:
  ```bash
  curl -u update:yourSecret \
    "https://your-ddns-host.example.com/nic/update?hostname=myhost.example.com&myip=$(curl -s ifconfig.me)"
  ```
- A happy response is `good <ip>` (already updated) or `nochg <ip>` (nothing to do). Anything else means check the debug log.

## Step 5 - Make it automatic

- Add cron every 5 minutes (tweak as you like):
  ```bash
  */5 * * * * php /path/to/hetzner_dyndns.php --cron --realm=default
  ```
- Point your router or NAS DynDNS profile to the same `nic/update` URL with the password you set. IPv6 works too when the client sends `myipv6`.
- Legacy clients can still send `X-Authentication: <password>` or `?p=<password>` (password-only), but Basic Auth is recommended.

## Step 6 - Quick troubleshooting checklist

- 401 or prompt for auth: password mismatch or `.htaccess` not applied.
- `not_found`: wrong zone or hostname, or missing token permissions.
- SQLite write errors: fix file permissions or move the DB to a writable folder.
- Nothing changes: check `api_order` and make sure you set the right token for the realm.

## Nerd corner (how it actually works)

* **Architecture at a glance**
  - One PHP file, one config file, one SQLite database. Incoming DynDNS calls (`/nic/update` or `/v3/update`) are rewritten to `hetzner_dyndns.php`.
  - The script authenticates with your shared username/password, parses the hostname and optional `realm` override, caches known records in SQLite, and returns `good` immediately when nothing changed.

<br>

* **Configuration deep dive**
  - Shared settings: `auth_user`, `auth_password`, `auth_realm`, `history_db`, and optional `debug`/`debug_log`.
  - Notifications: enable `notifications.enabled`, pick `php` or `smtp`, set recipients, and decide if you want messages on success, failure, or both.
  - Realms: each realm holds `ttl`, `api_order`, `zone_name`, `console_token`, and `dns_token`. Override `zone_name` if your DynDNS endpoint lives on a subdomain but you update the parent zone.

<br>

* **Hetzner Console API flow** (current API)
  1. Resolve the zone via `/zones?name=<zone>` using the Hetzner Console API token.
  2. Fetch RRsets via `/zones/{id}/rrsets` (A and AAAA).
  3. Match the RRset name to your host (handles `@` at the apex).
  4. Call `set_records` to replace the records with the new IPs. Successful calls return an action; failures log `not_found` or permission errors.

<br>

* **DNS Console API flow** (legacy)
  1. Look up the zone ID with `/zones?name=<zone>` using `dns_token`.
  2. Find A/AAAA record IDs, cache them in SQLite, and update via `PUT /records/{id}`.
  3. Failures stay marked `needs_sync` for cron retries.

<br>

* **Transitioning between APIs**
  - Use `['console', 'dns']` while migrating. If Hetzner Console says `not_found`, the script falls back to DNS Console.
  - When a zone is fully on Console, drop `dns_token` or switch to `['console']` to avoid legacy calls and to get ahead of the DNS Console shutdown timeline.
  - Run `php hetzner_dyndns.php --cron` after config changes to flush pending work and confirm both APIs behave.

<br>

* **Multiple zones and realms**
  - Create one realm per zone or per subdomain. Example: a `gjsi.de` realm and a `ddns.gjsi.de` realm with different tokens and TTLs.
  - Use `realm=<name>` in the DynDNS query string if you host multiple domains with the same endpoint.
  - The optional CLI helper `hetzner_dyndns_listhosts.php` can print cached IPv4/IPv6 per realm without hitting the HTTP endpoint.

<br>

* **Notifications and observability**
  - Email notifications report successes and failures using PHP `mail()` or SMTP.
  - `debug` and `debug_log` capture request and response pairs for both APIs plus notification status.
  - Cron summaries print totals, successes, failures, and which API handled each host.

<br>

* **Security and deployment notes**
  - `.htaccess` blocks direct hits to the PHP and SQLite files and only exposes the DynDNS endpoints.
  - Keep tokens scoped to DNS and rotate them periodically.
  - Ensure the SQLite DB and debug log are writable by the PHP user; keep them out of public web roots when possible.
  - Use HTTPS on your DynDNS endpoint. Plain HTTP would leak your shared password.

## Conclusion

The bridge gives you a friendly DynDNS endpoint that survives Hetzner's API migration. Start with the quickstart steps to get updates flowing, then dip into the nerd corner when you want to tune realms, notifications, or the Hetzner Console / DNS Console split.

##### License: MIT

<!--

Contributor's Certificate of Origin

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I have
    the right to submit it under the license indicated in the file; or

(b) The contribution is based upon previous work that, to the best of my
    knowledge, is covered under an appropriate license and I have the
    right under that license to submit that work with modifications,
    whether created in whole or in part by me, under the same license
    (unless I am permitted to submit under a different license), as
    indicated in the file; or

(c) The contribution was provided directly to me by some other person
    who certified (a), (b) or (c) and I have not modified it.

(d) I understand and agree that this project and the contribution are
    public and that a record of the contribution (including all personal
    information I submit with it, including my sign-off) is maintained
    indefinitely and may be redistributed consistent with this project
    or the license(s) involved.

Signed-off-by: Florian Woehrl <fw@woehrl.biz>

-->
