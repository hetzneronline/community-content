---
SPDX-License-Identifier: MIT
path: "/tutorials/hetzner-ddns-bridge"
slug: "hetzner-ddns-bridge"
date: "2025-12-02"
title: "Hetzner DynDNS Bridge: Console + DNS Console API Support"
short_description: "How to use a PHP/SQLite-based bridge that keeps Hetzner DNS zones in sync via DNS Console (legacy) and the new Console API."
tags: ["Hetzner DNS", "Hetzner Cloud", "Automation", "PHP"]
author: "woehrl"
author_link: "https://github.com/woehrl"
author_img: "https://avatars.githubusercontent.com/u/7691653"
author_description: "S/W Architect, Full-Stack Senior Developer"
language: "en"
available_languages: ["en", "de"]
header_img: "header-x"
cta: "product"
---

## Introduction

Need your IPv4/IPv6 address to follow you around the internet without babysitting your DNS? This tutorial walks you through a small PHP script that pretends to be a DynDNS server, speaks to both Hetzner Console DNS and the legacy DNS Console API, and plays nice with routers like a Fritz!Box. The first half is a hand-holding setup guide. The second half is the nerd zone with all the gory details. New DNS zones can no longer be created in DNS Console (as of 10 Nov 2025); plan to migrate every zone to Console and only keep DNS Console enabled while you finish that move.

## What you need

- A Hetzner account with at least one DNS zone (Console or DNS Console during migration).
- PHP with the `curl` and `SQLite3` extensions (typical web hosting or a small VM works fine).
- Somewhere to drop a PHP file and run cron every few minutes.
- A client that can call a DynDNS-style URL (router, NAS, or a simple curl command).

## Quickstart: from zero to working updates

### 0) Example: clean Debian/Ubuntu setup

If you start from a fresh minimal Debian/Ubuntu host, this gets you to a working test endpoint:

```bash
sudo apt update
sudo apt install -y apache2 libapache2-mod-php php-cli php-curl php-sqlite3
sudo a2enmod rewrite

sudo mkdir -p /var/www/hetzner-ddns
sudo cp /path/to/tutorials/hetzner-ddns-bridge/scripts/* /var/www/hetzner-ddns/
sudo chown -R www-data:www-data /var/www/hetzner-ddns

cat <<'EOF' | sudo tee /etc/apache2/sites-available/hetzner-ddns.conf
<VirtualHost *:80>
    ServerName ddns.example.com
    DocumentRoot /var/www/hetzner-ddns
    <Directory /var/www/hetzner-ddns>
        AllowOverride All
        Require all granted
    </Directory>
</VirtualHost>
EOF

sudo a2ensite hetzner-ddns
sudo systemctl reload apache2
```

Switch `ServerName` to your DynDNS endpoint. Use HTTPS in production (Let's Encrypt works fine).

### 1) Grab the files

- Use the files bundled with this tutorial in `tutorials/hetzner-ddns-bridge/scripts` (mirrored from https://github.com/woehrl/hetzner-dyndns, commit ceec8dd). Copy them to your web space or small VM.
- You need at least `hetzner_dyndns.php`, `hetzner_dyndns.config.php.dist`, the provided `.htaccess`, and optionally `hetzner_dyndns_listhosts.php`.

### 2) Create your config

```bash
cp hetzner_dyndns.config.php.dist hetzner_dyndns.config.php
```

Edit `hetzner_dyndns.config.php`:

- Set `script_password` to a strong shared password. Your router will use this.
- Decide which API to try first: set `api_order` to `['console', 'dns']` for a smooth migration or `['console']` once every zone is on the new API.
- Add tokens:
  - Console: create a DNS API token in the Hetzner Cloud Console and paste it into `console_token`.
  - DNS Console (legacy): create a DNS token in DNS Console and paste it into `dns_token` (only if you still host zones there).
- Optionally: Pick an `auth_realm` label (anything friendly like "dynbridge").
- Optionally: Point `history_db` to a writable path (for example `__DIR__ . '/hetzner_dyndns.sqlite3'`).
- Optionally: Adjust TTL per realm if you want faster or slower propagation.

### 3) Put it on the internet (safely)

- Keep `hetzner_dyndns.config.php` out of public Git and file listings.
- Ensure `.htaccess` rewrites DynDNS endpoints to the script so old clients work:

```apache
RewriteEngine On
RewriteRule ^(nic/update|v3/update)$ hetzner_dyndns.php [L,QSA]
```

- If your host needs it, set the PHP user to be able to write the SQLite file and debug log.

### 4) Test an update

- Build the test URL (substitute your domain and desired host):

```
https://your-ddns-host.example.com/nic/update?hostname=myhost.example.com&myip=203.0.113.10
```

- Use HTTP Basic Auth. Most DynDNS clients send any username plus the password you set in `script_password`; you can also `curl` it:

```bash
curl -u user:yourSecret \
  "https://your-ddns-host.example.com/nic/update?hostname=myhost.example.com&myip=$(curl -s ifconfig.me)"
```

- A happy response is `good <ip>` (already updated) or `nochg <ip>` (nothing to do). Anything else means check the debug log.

### 5) Make it automatic

- Add cron every 5 minutes (tweak as you like):

```bash
*/5 * * * * php /path/to/hetzner_dyndns.php --cron --realm=default
```

- Point your router or NAS DynDNS profile to the same `nic/update` URL with the password you set. IPv6 works too when the client sends `myipv6`.

### 6) Quick troubleshooting checklist

- 401 or prompt for auth: password mismatch or `.htaccess` not applied.
- `not_found`: wrong zone or hostname, or missing token permissions.
- SQLite write errors: fix file permissions or move the DB to a writable folder.
- Nothing changes: check `api_order` and make sure you set the right token for the realm.

## Nerd corner (how it actually works)

### Architecture at a glance

- One PHP file, one config file, one SQLite database. Incoming DynDNS calls (`/nic/update` or `/v3/update`) are rewritten to `hetzner_dyndns.php`.
- The script authenticates with your shared password, parses the hostname and optional `realm` override, caches known records in SQLite, and returns `good` immediately when nothing changed.

### Configuration deep dive

- Shared settings: `script_password`, `auth_realm`, `history_db`, and optional `debug`/`debug_log`.
- Notifications: enable `notifications.enabled`, pick `php` or `smtp`, set recipients, and decide if you want messages on success, failure, or both.
- Realms: each realm holds `ttl`, `api_order`, `zone_name`, `console_token`, and `dns_token`. Override `zone_name` if your DynDNS endpoint lives on a subdomain but you update the parent zone.

### Console API flow (current API)

1. Resolve the zone via `/zones?name=<zone>` using the Console DNS token.
2. Fetch rrsets via `/zones/{id}/rrsets` (A and AAAA).
3. Match the rrset name to your host (handles `@` at the apex).
4. Call `set_records` to replace the records with the new IPs. Successful calls return an action; failures log `not_found` or permission errors.

### DNS Console API flow (legacy)

1. Look up the zone ID with `/zones?name=<zone>` using `dns_token`.
2. Find A/AAAA record IDs, cache them in SQLite, and update via `PUT /records/{id}`.
3. Failures stay marked `needs_sync` for cron retries.

### Transitioning between APIs

- Use `['console', 'dns']` while migrating. If Console says `not_found`, the script falls back to DNS Console.
- When a zone is fully on Console, drop `dns_token` or switch to `['console']` to avoid legacy calls and to get ahead of the DNS Console shutdown timeline.
- Run `php hetzner_dyndns.php --cron` after config changes to flush pending work and confirm both APIs behave.

### Multiple zones and realms

- Create one realm per zone or per subdomain. Example: a `gjsi.de` realm and a `ddns.gjsi.de` realm with different tokens and TTLs.
- Use `realm=<name>` in the DynDNS query string if you host multiple domains with the same endpoint.
- The optional CLI helper `hetzner_dyndns_listhosts.php` can print cached IPv4/IPv6 per realm without hitting the HTTP endpoint.

### Notifications and observability

- Email notifications report successes and failures using PHP `mail()` or SMTP.
- `debug` and `debug_log` capture request and response pairs for both APIs plus notification status.
- Cron summaries print totals, successes, failures, and which API handled each host.

### Security and deployment notes

- `.htaccess` blocks direct hits to the PHP and SQLite files and only exposes the DynDNS endpoints.
- Keep tokens scoped to DNS and rotate them periodically.
- Ensure the SQLite DB and debug log are writable by the PHP user; keep them out of public web roots when possible.
- Use HTTPS on your DynDNS endpoint. Plain HTTP would leak your shared password.

## Conclusion

The bridge gives you a friendly DynDNS endpoint that survives Hetzner's API migration. Start with the quickstart steps to get updates flowing, then dip into the nerd corner when you want to tune realms, notifications, or the Console/DNS Console split.

##### License: MIT

<!--

Contributor's Certificate of Origin

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I have
    the right to submit it under the license indicated in the file; or

(b) The contribution is based upon previous work that, to the best of my
    knowledge, is covered under an appropriate license and I have the
    right under that license to submit that work with modifications,
    whether created in whole or in part by me, under the same license
    (unless I am permitted to submit under a different license), as
    indicated in the file; or

(c) The contribution was provided directly to me by some other person
    who certified (a), (b) or (c) and I have not modified it.

(d) I understand and agree that this project and the contribution are
    public and that a record of the contribution (including all personal
    information I submit with it, including my sign-off) is maintained
    indefinitely and may be redistributed consistent with this project
    or the license(s) involved.

Signed-off-by: Florian Woehrl <fw@woehrl.biz>

-->
